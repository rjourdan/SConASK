package com.riverbed.sconask.util;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


import com.amazon.speech.speechlet.Session;
import com.riverbed.sconask.SconASKSessionInfo;

public class SconConfigFile {

	private static SconASKSessionInfo sessionInfo;
	private static final String CONFIG_FILE = "config.txt";
	private static final String URL = "URL";
	private static final String ORGID = "ORGID";
	private static final String USERNAME = "USERNAME";
	private static final String PASSWORD = "PASSWORD";
	//These will be used as the source of the configuration file's stored encrypted attributes.
   //  private static final Map<String, char[]> SECURE_ATTRIBUTES = new HashMap<String, char[]>();
     //private static final  Charset UTF8 = Charset.forName("UTF-8");
     //Ciphering (encryption and decryption) password/key, generated by google auth code
    //private static char[] CIPHERPASS = "1234567890".toCharArray();
    //private static byte[] iv;
    
    //Cipher salt.
    /*private static final byte[] SALT = {
        (byte) 0xde, (byte) 0x33, (byte) 0x10, (byte) 0x12,
        (byte) 0xde, (byte) 0x33, (byte) 0x10, (byte) 0x12,};
*/
    /**
     * 
     */
	private static boolean loadSessionInfo(){
		try(BufferedReader br = new BufferedReader(new FileReader(CONFIG_FILE))) {
		    sessionInfo = new SconASKSessionInfo();
		    
		    //first line should be the url
		    sessionInfo.setUrl(br.readLine());
		    
		    //second line should be orgID
		    sessionInfo.setOrgId(br.readLine());
		    
		    //third line should be username
		    sessionInfo.setUsername(br.readLine());
		    
		    //final line is the password
		    sessionInfo.setPassword(br.readLine());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			return false;
		}
		return true;
	}
	

	/**
	 * 
	 * @param session
	 */
	public static void setSessionAttributes(final Session session)
	{
		if(sessionInfo==null) 
		{
			if(!loadSessionInfo()) System.out.println("problem reading the config file");
		}
			
		session.setAttribute(URL, sessionInfo.getUrl());
		session.setAttribute(ORGID, sessionInfo.getOrgId());
		session.setAttribute(USERNAME,sessionInfo.getUsername());
		session.setAttribute(PASSWORD, sessionInfo.getPassword());
	}
	
	
	/**
	 * 
	 * @return
	 */
	public SconASKSessionInfo getSession() {
		return sessionInfo;
	}
	
//	
//    /**
//     * 
//     * @param property
//     * @return
//     * @throws GeneralSecurityException
//     */
//    private static byte[] encrypt(byte[] property) throws GeneralSecurityException {
//        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
//        KeySpec spec = new PBEKeySpec(CIPHERPASS, SALT, 65536, 256);
//        SecretKey tmp = factory.generateSecret(spec);
//        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), "AES");
//        
//        Cipher pbeCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
//        pbeCipher.init(Cipher.ENCRYPT_MODE, secret);
//        AlgorithmParameters params = pbeCipher.getParameters();
//        iv = params.getParameterSpec(IvParameterSpec.class).getIV();
//        
//        //Encrypt and save to temporary storage.
//        System.out.println("encrypted ----"+pbeCipher.doFinal(property)+"----\n");
//        byte[] encrypted = pbeCipher.doFinal(property);
//
//        //Cleanup data-sources - Leave no traces behind.
//        for (int i = 0; i < property.length; i++) {
//            property[i] = 0;
//        }
//        property = null;
//        System.gc();
//
//        //Return encryption result.
//        return encrypted;
//    }
//    
//    /**
//     * 
//     * @param property
//     * @return
//     * @throws GeneralSecurityException
//     */
//    private static byte[] encrypt(char[] property) throws GeneralSecurityException {
//        //Prepare and encrypt.
//        byte[] bytes = new byte[property.length];
//        for (int i = 0; i < property.length; i++) {
//            bytes[i] = (byte) property[i];
//        }
//        byte[] encrypted = encrypt(bytes);
//
//        
//        return encrypted;
//    }
//
//    /**
//     * 
//     * @param property
//     * @return
//     * @throws GeneralSecurityException
//     * @throws UnsupportedEncodingException 
//     */
//    private static byte[] encrypt(String property) throws GeneralSecurityException, UnsupportedEncodingException {
//    	byte[] encrypted = encrypt(property.getBytes("UTF8"));
//        /*
//         * Strings can't really have their allocated data cleaned before CG,
//         * that's why secure data should be handled with char[] or byte[].
//         * Still, don't forget to set for GC, even for data of sesser importancy;
//         * You are making everything safer still, and freeing up memory as bonus.
//         */
//        property = null;
//        return encrypted;
//    }
//
//    /**
//     * 
//     * @param property
//     * @return
//     * @throws GeneralSecurityException
//     * @throws IOException
//     */
//    private static String decrypt(byte[] property) throws GeneralSecurityException, IOException {
//    	SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
//        KeySpec spec = new PBEKeySpec(CIPHERPASS, SALT, 65536, 256);
//        SecretKey tmp = factory.generateSecret(spec);
//        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), "AES");
//        
//        Cipher pbeCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
//    	pbeCipher.init(Cipher.DECRYPT_MODE, secret,new IvParameterSpec(iv));
//    	
//    	System.out.println("property "+property+"\n");
//    	String plaintext = new String(pbeCipher.doFinal(property), "UTF-8");
//        return plaintext;
//    }
//
//    /**
//     * 
//     * @param fileName
//     * @param secureAttributes
//     * @param layers
//     * @throws GeneralSecurityException
//     * @throws FileNotFoundException
//     * @throws IOException
//     */
//    private static void create_EncryptedFile(String fileName,Map<String, char[]> secureAttributes,int layers)
//                    throws GeneralSecurityException, FileNotFoundException, IOException {
//        StringBuilder sb = new StringBuilder();
//        
//        //First encryption layer. Encrypts secure attribute values
//        byte[] encryptedUrl = encrypt(secureAttributes.get(URL));
//        //sb.append(encryptedUrl).append(System.lineSeparator());
//        byte[] encryptedOrgId = encrypt(secureAttributes.get(ORGID));
//        //sb.append(encryptedOrgId).append(System.lineSeparator());
//        byte[] encryptedUsername = encrypt(secureAttributes.get(USERNAME));
//        //sb.append(encryptedUsername).append(System.lineSeparator());
//        byte[] encryptedPwd = encrypt(secureAttributes.get(PASSWORD));
//        //sb.append(encryptedPwd).append(System.lineSeparator());
//        
//        //Prepare file and file-writing process.
//        File f = new File(fileName);
//        //we erase current file with plain text codes
//        if (f.exists()) {
//            f.delete();
//        }
//        //BufferedWriter bw = new BufferedWriter(new FileWriter(f));
//      //  bw.write(str);
//        //Second encryption layer. Encrypts whole file content including previously encrypted stuff.
//        //bw.append(iv.toString().trim()+System.lineSeparator());
//        FileOutputStream fos = new FileOutputStream(fileName);
//        fos.write(encryptedUrl, 0, encryptedUrl.length);
//        fos.flush();
//        fos.close();
//        if (layers >= 2) {
//            //bw.append(encrypt(sb.toString().trim()));
//        } else {
//            //bw.write(encryptedUrl);
//        }
//       // bw.flush();
//        //bw.close();
//    }
//
//    private static String readFile_NoDecryption(String fileName) throws FileNotFoundException, IOException, GeneralSecurityException {
//        File f = new File(fileName);
//        BufferedReader br = new BufferedReader(new FileReader(f));
//        StringBuilder sb = new StringBuilder();
//        while (br.ready()) {
//            sb.append(br.readLine()).append(System.lineSeparator());
//        }
//        br.close();
//        return sb.toString();
//    }
//
//    private static String readFile_ApplyDecryption(String fileName) throws FileNotFoundException, IOException, GeneralSecurityException {
//        File f = new File(fileName);
//        //BufferedReader br = new BufferedReader(new FileReader(f));
//        //StringBuilder sb = new StringBuilder();
//        //if(br.ready()) CIPHERPASS = br.readLine().toCharArray();
//        byte[] plainText;
//        /*while (br.ready()) {
//        	plainText = decrypt(br.readLine());
//            sb.append(plainText).append(System.lineSeparator());
//        }
//        br.close();*/
//        FileInputStream fis = new FileInputStream(f);
//        fis.read(data, 0, data.length);
//        fis.close();
//        return sb.toString();
//    }
//	
//	public static void main(String[] args) throws GeneralSecurityException, FileNotFoundException, IOException {
//		SconConfigFile config = new SconConfigFile();
//		config.readSessionInfo();
//		SconASKSessionInfo info = config.getSession();
//
//    	        /*
//         * Set secure attributes.
//         * NOTE: Ignore the use of Strings here, it's being used for convenience only.
//         * In real implementations, JPasswordField.getPassword() would send the arrays directly.
//         */
//		SECURE_ATTRIBUTES.put(SconConfigFile.URL, info.getUrl().toCharArray());
//        SECURE_ATTRIBUTES.put(SconConfigFile.ORGID, info.getOrgId().toCharArray());
//		SECURE_ATTRIBUTES.put(SconConfigFile.USERNAME, info.getUsername().toCharArray());
//        SECURE_ATTRIBUTES.put(SconConfigFile.PASSWORD, info.getPassword().toCharArray());
//
//       
//        
//        //File completely encrypted, including re-encryption of secure attributes.
//        create_EncryptedFile(SconConfigFile.CONFIG_FILE, SECURE_ATTRIBUTES, 1);
//
//        /*
//         * Show contents of all three encryption levels, from file.
//         */
//        System.out.println("simple LAYER ENCRYPTION: \n" + readFile_NoDecryption(CONFIG_FILE) + "\n\n\n");
//
//        /*
//         * Decryption is demonstrated with the Double-Layer encryption file.
//         */
//        //Descrypt first layer. (file content) (REMEMBER: Layers are in reverse order from writing).
//        String decryptedContent = readFile_ApplyDecryption(CONFIG_FILE);
//        System.out.println("READ: [first layer decrypted]\n" + decryptedContent + "\n\n\n");
//        //Decrypt second layer (secure data).
//        for (String line : decryptedContent.split("\n")) {
//            String[] pair = line.split(": ", 2);
//            if (pair[0].equalsIgnoreCase("Username") || pair[0].equalsIgnoreCase("Password")) {
//                System.out.println("Decrypted: " + pair[0] + ": " + decrypt(pair[1]));
//            }
//        }
//    }
//	
	
	
}
